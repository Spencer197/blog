<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>

<h2>Comments</h2>
<%= render @article.comments %><!-- As the render method iterates over the @article.comments collection,
    it assigns each comment to a local variable named the same as the partial, in this case, 'comment', which is
    then available in the partial for us to show.

This gray code was replaced by the 'partial':app/views/comments/_comment.html.erb to reduce code.
<h2>Comments</h2>Adds a "Commenter" to the show.html.erb template
<% @article.comments.each do |comment| %>
  <p>
    <strong>Commenter:</strong>
    <%= comment.commenter %>
  </p>

  <p>
    <strong>Comment:</strong>
    <%= comment.body %>
  </p>
<% end %>
The colored code below, adds a form on the Article show page that creates a new comment by calling
the CommentsController create action. The form_for call here uses an array,
which will build a nested route, such as /articles/1/comments.-->
<!--<h2>Add a comment:</h2>-->
<%= render 'comments/form' %><!--The second render here defines the partial template we want to render,
    comments/form. Rails is smart enough to spot the forward slash in that string and realize that you
    want to render the _form.html.erb file in the app/views/comments directory.
    *@article is available to any partials rendered in the view because we defined it as an instance variable.

The gray code below has been copied to its own partial:app/views/comments/_form.html
<%= form_for([@article, @article.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>-->

<%= link_to 'Edit', edit_article_path(@article) %> |<!--Add an "Edit" link to the articles page.-->
<%= link_to 'Back', articles_path %><!--This link sends user back to the index of articles.-->
